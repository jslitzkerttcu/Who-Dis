{
  "code_quality": [
    {
      "id": "cq-001",
      "type": "code_quality",
      "title": "Split monolithic database.py into domain-specific modules",
      "description": "The file app/blueprints/admin/database.py has grown to 2532 lines with 43+ functions handling unrelated concerns: database health, table stats, session management, cache operations, error logs, API token management, and extensive HTML rendering. This violates single responsibility and makes the code difficult to navigate, test, and maintain.",
      "rationale": "This 'god module' pattern increases cognitive load, makes code reviews extremely difficult, leads to merge conflicts, and prevents modular testing. Functions for cache management have no logical connection to error logging functions, yet they share the same file.",
      "category": "large_files",
      "severity": "critical",
      "affectedFiles": [
        "app/blueprints/admin/database.py"
      ],
      "currentState": "Single 2532-line file handling: database health (lines 19-120), table stats (124-284), error stats (285-309), session stats (310-331), cache status (332-358), cache refresh (359-498), cache clearing (499-603), database optimization (604-681), audit export (682-756), error logs (757-837), sessions (838-949), token status (950-1007), plus 14 HTML rendering functions (1008-2532)",
      "proposedChange": "Split into focused modules:\n- app/blueprints/admin/db/__init__.py (blueprint, routes)\n- app/blueprints/admin/db/health.py (database_health, database_tables, optimize)\n- app/blueprints/admin/db/cache.py (cache_status, refresh_cache, clear_caches)\n- app/blueprints/admin/db/sessions.py (session management)\n- app/blueprints/admin/db/tokens.py (API token operations)\n- app/blueprints/admin/db/errors.py (error log viewing)\n- Move all _render_* functions to Jinja2 templates",
      "codeExample": "# Current structure:\n# database.py (2532 lines, 43+ functions)\n\n# Proposed structure:\n# db/\n#   __init__.py (imports and blueprint registration)\n#   health.py (~150 lines)\n#   cache.py (~300 lines)\n#   sessions.py (~150 lines)\n#   tokens.py (~200 lines)\n#   errors.py (~100 lines)\n# templates/admin/db/\n#   _health_stats.html\n#   _cache_status.html\n#   _table_stats.html\n#   (etc.)",
      "bestPractice": "Single Responsibility Principle - each module should have one reason to change. Flask blueprints can be nested for better organization.",
      "metrics": {
        "lineCount": 2532,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": 0
      },
      "estimatedEffort": "large",
      "breakingChange": false,
      "prerequisites": [
        "Create comprehensive test coverage before refactoring to prevent regressions",
        "Extract _render_* functions to templates first"
      ]
    },
    {
      "id": "cq-002",
      "type": "code_quality",
      "title": "Extract inline HTML rendering to Jinja2 templates",
      "description": "There are 26+ _render_* functions across the codebase generating HTML strings directly in Python code. The largest offenders are in search/__init__.py (15 functions, ~1400 lines of HTML) and admin/database.py (10 functions, ~800 lines of HTML). This violates separation of concerns and makes the HTML difficult to maintain.",
      "rationale": "Inline HTML in Python is an anti-pattern that: 1) Makes HTML changes require Python expertise, 2) Prevents IDE HTML syntax highlighting/validation, 3) Complicates template inheritance and reuse, 4) Makes XSS vulnerabilities harder to spot, 5) Bloats Python files unnecessarily. The project already uses Jinja2 templates for other views.",
      "category": "code_smells",
      "severity": "major",
      "affectedFiles": [
        "app/blueprints/search/__init__.py",
        "app/blueprints/admin/database.py",
        "app/blueprints/admin/users.py",
        "app/blueprints/admin/config.py",
        "app/blueprints/admin/audit.py",
        "app/blueprints/session/__init__.py"
      ],
      "currentState": "26 functions generating HTML via f-strings:\n- _render_azure_ad_card (~200 lines)\n- _render_genesys_card (~230 lines)\n- _render_keystone_card (~190 lines)\n- _render_unified_profile (~180 lines)\n- _render_cache_status (~280 lines)\n- _render_table_statistics (~45 lines)\n- etc.",
      "proposedChange": "Create partial templates in templates/partials/ or templates/htmx/:\n- templates/htmx/search/_azure_ad_card.html\n- templates/htmx/search/_genesys_card.html\n- templates/htmx/admin/_cache_status.html\n- templates/htmx/admin/_table_stats.html\n\nReplace _render_* calls with render_template('htmx/...', data=data)",
      "codeExample": "# Current:\ndef _render_azure_ad_card(user_data):\n    display_name = user_data.get('displayName', 'Unknown')\n    html = f'''\n    <div class=\"bg-white rounded-lg...\">\n        <h3>{display_name}</h3>\n    </div>\n    '''\n    return html\n\n# Proposed:\ndef _render_azure_ad_card(user_data):\n    return render_template(\n        'htmx/search/_azure_ad_card.html',\n        user=user_data\n    )",
      "bestPractice": "Separation of Concerns - presentation logic belongs in templates, not Python code. HTMX-specific fragments should use Jinja2 for consistency with full-page templates.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": 2200,
        "testCoverage": 0
      },
      "estimatedEffort": "large",
      "breakingChange": false,
      "prerequisites": [
        "Create templates/htmx/ directory structure",
        "Ensure all existing Jinja2 macros are reusable"
      ]
    },
    {
      "id": "cq-003",
      "type": "code_quality",
      "title": "Implement automated test suite for critical services",
      "description": "The project has zero test files despite having complex services handling LDAP authentication, Genesys Cloud API, Microsoft Graph integration, encryption, and compliance checking. The CLAUDE.md file notes 'No test framework is currently configured. When implementing tests, add pytest to requirements.txt.'",
      "rationale": "Without tests: 1) Refactoring is extremely risky - no way to verify changes don't break functionality, 2) Bug regression is likely, 3) New developers can't understand expected behavior, 4) CI/CD cannot validate deployments. The codebase has 260 'except Exception' catches that may be hiding bugs.",
      "category": "testing",
      "severity": "critical",
      "affectedFiles": [
        "app/services/ldap_service.py",
        "app/services/genesys_service.py",
        "app/services/graph_service.py",
        "app/services/encryption_service.py",
        "app/services/configuration_service.py",
        "app/services/search_orchestrator.py",
        "app/services/compliance_checking_service.py"
      ],
      "currentState": "Zero test files. No pytest in requirements.txt. No tests/ directory. Critical services like encryption, authentication, and compliance have no test coverage.",
      "proposedChange": "Create test infrastructure:\n1. Add pytest, pytest-cov, pytest-flask to requirements.txt\n2. Create tests/ directory with:\n   - tests/conftest.py (fixtures, test database)\n   - tests/unit/services/ (service unit tests)\n   - tests/integration/ (API integration tests)\n3. Start with highest-risk services:\n   - tests/unit/services/test_encryption_service.py\n   - tests/unit/services/test_configuration_service.py\n   - tests/unit/services/test_ldap_service.py",
      "codeExample": "# tests/unit/services/test_encryption_service.py\nimport pytest\nfrom app.services.encryption_service import EncryptionService\n\nclass TestEncryptionService:\n    def test_encrypt_decrypt_roundtrip(self):\n        service = EncryptionService()\n        plaintext = 'sensitive_api_key'\n        encrypted = service.encrypt(plaintext)\n        decrypted = service.decrypt(encrypted)\n        assert decrypted == plaintext\n\n    def test_encrypt_returns_different_ciphertext(self):\n        service = EncryptionService()\n        encrypted1 = service.encrypt('test')\n        encrypted2 = service.encrypt('test')\n        assert encrypted1 != encrypted2  # IV should differ",
      "bestPractice": "Test-Driven Development - critical security and data handling code should have comprehensive test coverage. Aim for 80%+ coverage on services layer.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": 0
      },
      "estimatedEffort": "large",
      "breakingChange": false,
      "prerequisites": [
        "Set up test database configuration",
        "Configure pytest in pyproject.toml or setup.cfg"
      ]
    },
    {
      "id": "cq-004",
      "type": "code_quality",
      "title": "Refine overly broad exception handling across 42 files",
      "description": "The codebase contains 260 instances of 'except Exception' across 42 files. Many of these catch-all handlers silently swallow errors or log generic messages, making debugging difficult and potentially hiding important failures. The worst offenders are audit_service_postgres.py (21), genesys_cache_db.py (12), ldap_service.py (12), and simple_config.py (10).",
      "rationale": "Broad exception handling: 1) Hides specific error types that callers might want to handle differently, 2) Makes debugging harder when logs show only 'Error occurred', 3) Can mask programming errors like AttributeError or KeyError, 4) Violates the principle of 'fail fast' for unexpected conditions. Some errors should propagate to trigger proper error handling upstream.",
      "category": "code_smells",
      "severity": "minor",
      "affectedFiles": [
        "app/services/audit_service_postgres.py",
        "app/services/genesys_cache_db.py",
        "app/services/ldap_service.py",
        "app/services/simple_config.py",
        "app/__init__.py",
        "app/app_factory.py",
        "app/blueprints/admin/database.py"
      ],
      "currentState": "260 'except Exception' blocks, many with:\n- Generic error messages: logger.error(f'Error: {e}')\n- Silent failures: return None or return []\n- No differentiation between recoverable and fatal errors",
      "proposedChange": "1. Identify specific exception types for each operation:\n   - ConnectionError, TimeoutError for network operations\n   - KeyError, ValueError for data validation\n   - ldap3.LDAPException for LDAP operations\n   - psycopg2.Error for database operations\n\n2. Create custom exception hierarchy in app/exceptions.py:\n   - WhoDisException (base)\n   - ServiceUnavailableError\n   - ConfigurationError\n   - DataValidationError\n\n3. Allow unexpected exceptions to propagate where appropriate",
      "codeExample": "# Current:\ntry:\n    result = ldap_conn.search(...)\nexcept Exception as e:\n    logger.error(f'LDAP error: {e}')\n    return None\n\n# Proposed:\nfrom ldap3.core.exceptions import LDAPException\nfrom app.exceptions import ServiceUnavailableError\n\ntry:\n    result = ldap_conn.search(...)\nexcept LDAPSocketOpenError as e:\n    logger.warning(f'LDAP connection failed: {e}')\n    raise ServiceUnavailableError('LDAP server unreachable') from e\nexcept LDAPException as e:\n    logger.error(f'LDAP query failed: {e}', exc_info=True)\n    return None\n# Let other exceptions propagate",
      "bestPractice": "Catch specific exceptions - handle what you can, let the rest propagate. Use custom exception types to communicate error categories to callers.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "medium",
      "breakingChange": false,
      "prerequisites": [
        "Create app/exceptions.py with custom exception hierarchy",
        "Review each catch block to determine appropriate handling"
      ]
    },
    {
      "id": "cq-005",
      "type": "code_quality",
      "title": "Add ruff/mypy configuration and pre-commit hooks",
      "description": "While ruff and mypy are in requirements.txt, there is no configuration file (pyproject.toml, ruff.toml) to define linting rules, and no pre-commit hooks to enforce code quality. This means code style and type checking are not consistently enforced across the team.",
      "rationale": "Without standardized linting configuration: 1) Different developers may use different settings, 2) CI/CD cannot enforce consistent code quality, 3) Type errors may go unnoticed until runtime, 4) Code formatting inconsistencies persist. Pre-commit hooks catch issues before they enter the codebase.",
      "category": "linting",
      "severity": "minor",
      "affectedFiles": [
        "requirements.txt",
        "(missing pyproject.toml)",
        "(missing .pre-commit-config.yaml)"
      ],
      "currentState": "ruff and mypy listed in requirements.txt but no configuration files. Running 'ruff check .' uses default settings. No pre-commit hooks configured.",
      "proposedChange": "1. Create pyproject.toml with comprehensive configuration:\n   - ruff settings (line length, ignored rules, per-file ignores)\n   - mypy settings (strict mode, plugin for Flask)\n   - pytest settings\n\n2. Create .pre-commit-config.yaml with hooks:\n   - ruff (linting + formatting)\n   - mypy (type checking)\n   - trailing-whitespace, end-of-file-fixer\n\n3. Document in CLAUDE.md how to install and use pre-commit",
      "codeExample": "# pyproject.toml\n[tool.ruff]\nline-length = 100\ntarget-version = \"py312\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"W\", \"I\", \"B\", \"C4\", \"UP\"]\nignore = [\"E501\"]  # Line too long (handled by formatter)\n\n[tool.ruff.lint.per-file-ignores]\n\"app/blueprints/admin/database.py\" = [\"C901\"]  # Complex functions until refactored\n\n[tool.mypy]\npython_version = \"3.12\"\nwarn_return_any = true\nwarn_unused_ignores = true\nplugins = [\"sqlalchemy.ext.mypy.plugin\"]\n\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.8.6\n    hooks:\n      - id: ruff\n        args: [--fix]\n      - id: ruff-format",
      "bestPractice": "Consistent code style through automated tooling. Pre-commit hooks enforce quality at commit time, reducing code review friction.",
      "metrics": {
        "lineCount": null,
        "complexity": null,
        "duplicateLines": null,
        "testCoverage": null
      },
      "estimatedEffort": "small",
      "breakingChange": false,
      "prerequisites": [
        "Install pre-commit: pip install pre-commit",
        "Run initial formatting: ruff format . && ruff check --fix ."
      ]
    }
  ],
  "metadata": {
    "filesAnalyzed": 82,
    "largeFilesFound": 12,
    "duplicateBlocksFound": 26,
    "lintingConfigured": false,
    "testsPresent": false,
    "generatedAt": "2025-12-29T22:58:00Z",
    "summary": {
      "critical": 2,
      "major": 1,
      "minor": 2,
      "suggestion": 0
    },
    "topPriorityIssues": [
      "database.py at 2532 lines (god module)",
      "search/__init__.py at 2470 lines (god module)",
      "Zero test coverage",
      "26+ inline HTML render functions",
      "260 broad exception catches"
    ]
  }
}
